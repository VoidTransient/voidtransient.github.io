# BackTrace
## 1. 子集型
```cpp
//输入
int n; cin >> n
vector<int> a(n);
for(int& i : a) cin >> a;
```
### (1) Choose Or Not
```cpp
//生成所有子集
vector<vector<int> ans;
vector<int> path;

auto dfs = [&](this auto&& dfs, int i) -> void
{
	if(i == n)
	{
		ans.emplace_back(path);
		return;
	}
	
	dfs(i + 1);
	
	path.push_back(a[i]);
	dfs(i + 1);
	path.pop_back();
};
dfs(0);

```
### (2) Enumerate Answer
```cpp
vector<vector<int> ans;
vector<int> path;

auto dfs = [&](this auto&& dfs, int i) -> void
{
	ans.emplace_back(path);
	
	for(int j = i; j < n; j++)
	{
		path.push_back(a[j]);
		dfs(j + 1);
		path.pop_back();
	}
};
dfs(0);
```

### (3) 二进制枚举(?)
```cpp
vector<vector<int>> ans(1 << n);
	
for(int i = 0; i < (1 << n); i++)
	for(int j = 0; j < n; j++)
		if(i >> j & 1) 
			ans[i].push_back(a[j]);

```

## 2. 组合型
```cpp
vector<vector<int>> ans;
vector<int> path;

auto dfs = [&](this auto&& dfs, int i) -> void
{
	if(path.size() == k)
	{
		ans.push_back(path);
		return;
	}
	
	if(path.size() + n - i + 1 < k) return;
	
	dfs(i + 1);
	
	path.push_back(i);
	dfs(i + 1);
	path.pop_back();
};

dfs(1);
```

## 3. 排列型
```cpp
vector<vector<int>> ans;
vector<int> path(n);//采用覆盖写法，使用used来记录使用情况，所以不用恢复path
vector<bool> used(n);//默认全部初始化为false

auto dfs = [&](this auto&& dfs, int i) -> void
{
	if(i == n)
	{
		ans.emplace_back(path);
		return;
	}
	
	for(int j = 0; j < n; i++)
	{
		if(!used[j])
		{
			path[i] = nums[j];//第i个位置 = [0, n)
			used[j] = true;
			dfs(i + 1);//枚举下一个位置
			used[j] = false;
		}
	}
};
//dfs(i)表示枚举第i个位置
dfs(0);
```
