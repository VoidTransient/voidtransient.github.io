# Dijkstra With Heap Optimization

>[!NOTE]
>类型：单源最短路
>适用：非负权图
>时间复杂度：O((n + m) log2 n)
>空间复杂度：O(n + m)

```cpp
struct edge
{
    int v, w;
};

struct node
{
    int dis, u;
    bool operator>(const node &a) const { return dis > a.dis; }
};
  
vector<vector<edge>> e;
vector<int> dis, pre;
vector<bool> vis;
  
// 回溯 a 到 b 的最短路径
vector<int> get_path(int a, int b)
{
    if (dis[b] == INF) return {};  // 不可达，返回空
    vector<int> res;
    for (int cur = b; cur != a; cur = pre[cur])
        res.push_back(cur);
    res.push_back(a);
    reverse(all(res));
    return res;
}

void dijkstra(int s, int n)
{
    dis.assign(n + 1, INF);
    vis.assign(n + 1, false);
    pre.assign(n + 1, -1);
  
    dis[s] = 0;
    priority_queue<node, vector<node>, greater<node>> q;
    q.push({0, s});
    
    while (!q.empty())
    {
        int u = q.top().u;
        q.pop();

        if (vis[u]) continue;
        vis[u] = true;

        for (auto& [v, w] : e[u])
        {
            if (dis[v] > dis[u] + w)
            {
                dis[v] = dis[u] + w;
                pre[v] = u;  
                q.push({dis[v], v});
            }
        }
    }
}

void solve()
{
    int n, m;
    cin >> n >> m;

    e.assign(n + 1, vector<edge>());

    for (int i = 0; i < m; i++)
    {
        int u, v, w;
        cin >> u >> v >> w;
        e[u].push_back({v, w});
        e[v].push_back({u, w});  // 无向图
    }

    int a, b;
    cin >> a >> b;
  
    dijkstra(a, n); // 起点，顶点数
  
    vector<int> path = get_path(a, b);

    if (path.empty()) cout << -1 << endl;
    else vD(path);
}
```
# Floyd

>[!NOTE]
>类型：多源最短路
>适用：可含负权边，但不能有负环，n <= 400
>时间复杂度：O(n^3)
>空间复杂度：O(n^2)

```cpp
vector<vector<int>> dist;  // dist[i][j] = i到j的最短距离
vector<vector<int>> path;  // path[i][j] = i到j的最短路径中j的前一个节点

// 回溯a到b的最短路径
vector<int> get_path(int a, int b)
{
    if (dist[a][b] == INF) return {};  // 不可达
    vector<int> res;
    for (int cur = b; cur != a; cur = path[a][cur])
        res.push_back(cur);
    res.push_back(a);  
    reverse(all(res));  
    return res;
}

void floyd(int n)
{
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            path[i][j] = i != j && dist[i][j] != INF ? i : -1;

    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                if (dist[i][k] + dist[k][j] < dist[i][j])
                {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    path[i][j] = path[k][j];  
                }
}

void solve()
{
    int n, m;
    cin >> n >> m;

    dist.assign(n + 1, vector<int>(n + 1, INF));
    path.assign(n + 1, vector<int>(n + 1, -1));
    for (int i = 1; i <= n; i++)
        dist[i][i] = 0;  

    for (int i = 0; i < m; i++)
    {
        int u, v, w;
        cin >> u >> v >> w;
        if (w < dist[u][v])
        {
            dist[u][v] = w;
            dist[v][u] = w;  // 无向图
        }
    }

    floyd(n);

    int a, b;
    cin >> a >> b;

    vector<int> res = get_path(a, b);

    if (res.empty()) cout << -1 << endl;  
    else vD(res);  
}
```
# SPFA (Bellman–Ford With Queue Optimization)

>[!NOTE]
>类型：单源最短路
>适用：可含负权边，但不允许存在**从起点可达的负环**
>时间复杂度：O(m) ~ O(nm)
>空间复杂度：O(n + m)

```cpp
struct edge
{
    int v, w;
};
  
vector<vector<edge>> e;
vector<int> dis, cnt, pre;
vector<bool> vis;

// 回溯 a 到 b 的最短路径（需确保无负环且可达）
vector<int> get_path(int a, int b)
{
    if (dis[b] == INF) return {};
    vector<int> res;
    for (int cur = b; cur != a; cur = pre[cur])
        res.push_back(cur);
    res.push_back(a);
    reverse(all(res));
    return res;
}

bool spfa(int s, int n)
{
    dis.assign(n + 1, INF);
    cnt.assign(n + 1, 0);
    vis.assign(n + 1, false);
    pre.assign(n + 1, -1);

    dis[s] = 0;
    vis[s] = true;
    queue<int> q;
    q.push(s);

    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        vis[u] = false;
        for (auto [v, w] : e[u])
        {
            if (dis[v] > dis[u] + w)
            {
                dis[v] = dis[u] + w;
                pre[v] = u;  
                cnt[v] = cnt[u] + 1;
                if (cnt[v] >= n) return false;  // 存在负环
                if (!vis[v])
                {
                    q.push(v);
                    vis[v] = true;
                }
            }
        }
    }
    return true;  // 无负环
}

void solve()
{
    int n, m;
    cin >> n >> m;

    e.assign(n + 1, vector<edge>());

    for (int i = 0; i < m; i++)
    {
        int u, v, w;
        cin >> u >> v >> w;
        e[u].push_back({v, w});
        e[v].push_back({u, w});  // 无向图
    }

    int a, b;
    cin >> a >> b;

    bool has_negative_cycle = !spfa(a, n); // 起点，顶点数

    if (has_negative_cycle) cout << "不好!有负环!" << endl;
    else
    {
        vector<int> path = get_path(a, b);

        if (path.empty()) cout << -1 << endl;
        else vD(path);
    }
}
```

# Other
```cpp
#include <bits/stdc++.h>
#define inf 0x3f3f3f3f
#define INF 0x3f3f3f3f3f3f3f3f
#define MOD 1000000007
#define mod 998244353
#define all(_x) _x.begin(), _x.end()
#define vcin(_x) for(auto& _i : _x) cin >> _i
#define vvcin(_x) for(auto& _j : _x) for(auto& _i : _j) cin >> _i
#define D(_x) cout << _x << endl
#define vD(_x) for(int _i = 0; _i < _x.size(); _i++) cout << _x[_i] << " \n"[_i == _x.size() - 1]
#define input(n, a) int n; cin >> n; vector<int> a(n); vcin(a)
#define YES cout << "YES" << endl
#define NO cout << "NO" << endl
#define Yes cout << "Yes" << endl
#define No cout << "No" << endl
#define yes cout << "yes" << endl
#define no cout << "no" << endl
using namespace std;

#define int long long
#define endl '\n'

void solve()
{
	//Code
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int _ = 1;
cin >> _;
    while (_--)
        solve();
    return 0;
}
```

>[!IMPORTANT]
>solve()中的代码为调用示例
