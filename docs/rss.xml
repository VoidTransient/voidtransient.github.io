<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>VoidTransient's Blog</title><link>https://voidtransient.github.io</link><description>这里是VoidTransient的博客，欢迎你的到来OvO</description><copyright>VoidTransient's Blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/189825951?v=4</url><title>avatar</title><link>https://voidtransient.github.io</link></image><lastBuildDate>Fri, 17 Oct 2025 12:06:15 +0000</lastBuildDate><managingEditor>VoidTransient's Blog</managingEditor><ttl>60</ttl><webMaster>VoidTransient's Blog</webMaster><item><title>回溯</title><link>https://voidtransient.github.io/post/hui-su.html</link><description># BackTrace
## 1. 子集型
```cpp
//输入
int n; cin &gt;&gt; n
vector&lt;int&gt; a(n);
for(int&amp; i : a) cin &gt;&gt; a;
```
### (1) Choose Or Not
```cpp
//生成所有子集
vector&lt;vector&lt;int&gt; ans;
vector&lt;int&gt; path;

auto dfs = [&amp;](this auto&amp;&amp; dfs, int i) -&gt; void
{
	if(i == n)
	{
		ans.emplace_back(path);
		return;
	}
	
	dfs(i + 1);
	
	path.push_back(a[i]);
	dfs(i + 1);
	path.pop_back();
};
dfs(0);

```
### (2) Enumerate Answer
```cpp
vector&lt;vector&lt;int&gt; ans;
vector&lt;int&gt; path;

auto dfs = [&amp;](this auto&amp;&amp; dfs, int i) -&gt; void
{
	ans.emplace_back(path);
	
	for(int j = i; j &lt; n; j++)
	{
		path.push_back(a[j]);
		dfs(j + 1);
		path.pop_back();
	}
};
dfs(0);
```

### (3) 二进制枚举(?)
```cpp
vector&lt;vector&lt;int&gt;&gt; ans(1 &lt;&lt; n);
	
for(int i = 0; i &lt; (1 &lt;&lt; n); i++)
	for(int j = 0; j &lt; n; j++)
		if(i &gt;&gt; j &amp; 1) 
			ans[i].push_back(a[j]);

```

## 2. 组合型
```cpp
vector&lt;vector&lt;int&gt;&gt; ans;
vector&lt;int&gt; path;

auto dfs = [&amp;](this auto&amp;&amp; dfs, int i) -&gt; void
{
	if(path.size() == k)
	{
		ans.push_back(path);
		return;
	}
	
	if(path.size() + n - i + 1 &lt; k) return;
	
	dfs(i + 1);
	
	path.push_back(i);
	dfs(i + 1);
	path.pop_back();
};

dfs(1);
```

## 3. 排列型
```cpp
vector&lt;vector&lt;int&gt;&gt; ans;
vector&lt;int&gt; path(n);//采用覆盖写法，使用used来记录使用情况，所以不用恢复path
vector&lt;bool&gt; used(n);//默认全部初始化为false

auto dfs = [&amp;](this auto&amp;&amp; dfs, int i) -&gt; void
{
	if(i == n)
	{
		ans.emplace_back(path);
		return;
	}
	
	for(int j = 0; j &lt; n; i++)
	{
		if(!used[j])
		{
			path[i] = nums[j];//第i个位置 = [0, n)
			used[j] = true;
			dfs(i + 1);//枚举下一个位置
			used[j] = false;
		}
	}
};
//dfs(i)表示枚举第i个位置
dfs(0);
```
。</description><guid isPermaLink="true">https://voidtransient.github.io/post/hui-su.html</guid><pubDate>Fri, 17 Oct 2025 12:03:56 +0000</pubDate></item><item><title>TEST-1</title><link>https://voidtransient.github.io/post/TEST-1.html</link><description>Just a test...

![Image](https://github.com/user-attachments/assets/450b7baa-ace2-4c46-9cfc-8c22548ec88f)
。</description><guid isPermaLink="true">https://voidtransient.github.io/post/TEST-1.html</guid><pubDate>Fri, 17 Oct 2025 11:10:47 +0000</pubDate></item></channel></rss>